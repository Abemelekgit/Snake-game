<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover"
  />
  <meta name="theme-color" content="#0a0f1f" />
  <title>Snake</title>
  <style>
    :root {
      --bg: #0a0f1f;
      --grid: rgba(0, 255, 170, 0.06);
      --snake: #4af0ff;
      --snake-head: #ff2fd3;
      --food: #ffb347;
      --hud: rgba(8, 14, 30, 0.72);
      --accent: #7afcff;
      --btn: #11182b;
      --btn-border: #26ffe6;
      --glow: 0 0 14px rgba(122, 252, 255, 0.55);
      --font: "Segoe UI", "Helvetica Neue", sans-serif;
    }
    * { box-sizing: border-box; }
    html, body {
      margin: 0; padding: 0; width: 100%; height: 100%;
      background: radial-gradient(120% 120% at 10% 10%, #12203b 0%, #0a0f1f 40%, #050811 100%);
      font-family: var(--font); color: #e7f8ff; overflow: hidden; touch-action: none;
    }
    #game {
      position: relative; width: 100vw; height: 100vh; overflow: hidden;
    }
    canvas {
      position: absolute; inset: 0; width: 100%; height: 100%;
      background: linear-gradient(135deg, rgba(0,255,170,0.02), rgba(255,47,211,0.02));
    }
    #overlay {
      position: absolute; top: 0; left: 0; right: 0; padding: env(safe-area-inset-top, 12px) 16px 0;
      display: flex; justify-content: space-between; align-items: center; gap: 12px;
      background: linear-gradient(180deg, rgba(0,0,0,0.5) 0%, rgba(0,0,0,0) 100%);
      pointer-events: none;
    }
    .badge {
      pointer-events: auto;
      background: var(--hud); border: 1px solid var(--btn-border);
      padding: 10px 14px; border-radius: 10px; box-shadow: var(--glow);
      display: inline-flex; gap: 12px; align-items: center; font-weight: 600;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
    }
    .label { color: #7afcff; font-size: 13px; text-transform: uppercase; letter-spacing: 0.06em; }
    .value { font-size: 16px; color: #fff; }
    select {
      pointer-events: auto; background: var(--btn); color: #fff; border: 1px solid var(--btn-border);
      border-radius: 10px; padding: 8px 10px; font-weight: 700; letter-spacing: 0.04em;
      box-shadow: var(--glow); appearance: none; -webkit-appearance: none; outline: none;
    }
    #startBtn {
      pointer-events: auto;
      background: var(--btn); color: #fff; border: 1px solid var(--btn-border);
      padding: 10px 16px; border-radius: 12px; font-weight: 700; letter-spacing: 0.04em;
      box-shadow: var(--glow); cursor: pointer; transition: transform 0.15s ease, box-shadow 0.2s ease;
    }
    #startBtn:active { transform: scale(0.97); box-shadow: 0 0 4px rgba(122,252,255,0.35); }
    #dpad {
      position: absolute; inset: 50% 0 0 0; display: grid; place-items: center;
      pointer-events: none; touch-action: none;
    }
    .dpad-grid {
      width: 220px; height: 220px; display: grid; grid-template-rows: repeat(3, 1fr); grid-template-columns: repeat(3, 1fr);
      gap: 8px; opacity: 0.65;
    }
    .btn {
      background: rgba(17, 24, 43, 0.55); border: 1px solid rgba(38, 255, 230, 0.3);
      border-radius: 12px; box-shadow: var(--glow); pointer-events: auto; touch-action: none;
      display: grid; place-items: center; color: #7afcff; font-weight: 700; user-select: none;
    }
    .btn:active { background: rgba(38,255,230,0.25); }
    .btn.pressed { background: rgba(38,255,230,0.25); box-shadow: 0 0 12px rgba(122,252,255,0.7); }
    .btn span { font-size: 18px; }
    .hidden { display: none; }
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.08); }
      100% { transform: scale(1); }
    }
    .pulse { animation: pulse 0.3s ease; }
    .highlight { animation: pulse 0.5s ease; color: #ffd166; text-shadow: 0 0 8px rgba(255,209,102,0.6); }
  </style>
</head>
<body>
  <div id="game">
    <canvas id="canvas"></canvas>
    <div id="overlay">
      <div class="badge"><span class="label">Score</span><span class="value" id="score">0</span></div>
      <div class="badge"><span class="label">High</span><span class="value" id="high">0</span></div>
      <div class="badge"><span class="label">Length</span><span class="value" id="length">3</span></div>
      <div class="badge"><span class="label">Last</span><span class="value" id="last">0</span></div>
      <div class="badge">
        <span class="label">Mode</span>
        <select id="modeSelect">
          <option value="chill">Chill</option>
          <option value="classic" selected>Classic</option>
          <option value="hard">Hard</option>
        </select>
      </div>
      <div class="badge"><span class="label">Speed</span><span class="value" id="speed">110ms</span></div>
      <button id="startBtn">Start</button>
    </div>
    <div id="dpad">
      <div class="dpad-grid">
        <div></div>
        <div class="btn" data-dir="up"><span>▲</span></div>
        <div></div>
        <div class="btn" data-dir="left"><span>◀</span></div>
        <div></div>
        <div class="btn" data-dir="right"><span>▶</span></div>
        <div></div>
        <div class="btn" data-dir="down"><span>▼</span></div>
        <div></div>
      </div>
    </div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      const scoreEl = document.getElementById("score");
      const highEl = document.getElementById("high");
      const lengthEl = document.getElementById("length");
      const lastEl = document.getElementById("last");
      const speedEl = document.getElementById("speed");
      const startBtn = document.getElementById("startBtn");
      const modeSelect = document.getElementById("modeSelect");
      const dpadButtons = document.querySelectorAll(".btn[data-dir]");
      const HIGH_KEY = "snake_highscore";
      const MODE_KEY = "snake_mode";
      let highScore = parseInt(localStorage.getItem(HIGH_KEY) || "0", 10);
      highEl.textContent = highScore;

      const difficulties = {
        chill: { speed: 140 },
        classic: { speed: 110 },
        hard: { speed: 80 }
      };
      const savedMode = localStorage.getItem(MODE_KEY);
      if (savedMode && difficulties[savedMode]) {
        modeSelect.value = savedMode;
      }
      let currentMode = modeSelect.value;

      let cellSize = 20, cols = 24, rows = 32;
      let snake = [];
      let dir = { x: 1, y: 0 };
      let nextDir = { x: 1, y: 0 };
      let food = { x: 0, y: 0 };
      let score = 0;
      let loopId = null;
      let speedMs = difficulties[currentMode].speed;
      let paused = false;

      const resize = () => {
        const w = window.innerWidth;
        const h = window.innerHeight;
        canvas.width = w;
        canvas.height = h;
        cellSize = Math.max(12, Math.floor(Math.min(w, h) / 24));
        cols = Math.max(12, Math.floor(w / cellSize));
        rows = Math.max(12, Math.floor(h / cellSize));
      };

      const randInt = (max) => Math.floor(Math.random() * max);

      const placeFood = () => {
        let fx, fy, safe = false;
        while (!safe) {
          fx = randInt(cols);
          fy = randInt(rows);
          safe = !snake.some(s => s.x === fx && s.y === fy);
        }
        food = { x: fx, y: fy };
      };

      const reset = () => {
        resize();
        const cx = Math.floor(cols / 2);
        const cy = Math.floor(rows / 2);
        snake = [
          { x: cx - 1, y: cy },
          { x: cx, y: cy },
          { x: cx + 1, y: cy }
        ];
        dir = { x: 1, y: 0 };
        nextDir = { ...dir };
        score = 0;
        scoreEl.textContent = score;
        lengthEl.textContent = snake.length;
        placeFood();
      };

      const setDirection = (x, y) => {
        if (x === -dir.x && y === -dir.y) return; // prevent 180 turn
        nextDir = { x, y };
      };

      const tick = () => {
        if (paused) return;
        dir = { ...nextDir };
        const head = { x: snake[snake.length - 1].x + dir.x, y: snake[snake.length - 1].y + dir.y };

        // collisions
        if (head.x < 0 || head.y < 0 || head.x >= cols || head.y >= rows ||
            snake.some(s => s.x === head.x && s.y === head.y)) {
          gameOver();
          return;
        }

        snake.push(head);
        if (head.x === food.x && head.y === food.y) {
          score += 10;
          scoreEl.textContent = score;
          if ("vibrate" in navigator) navigator.vibrate(40);
          scoreEl.classList.remove("pulse");
          void scoreEl.offsetWidth;
          scoreEl.classList.add("pulse");
          if (score > highScore) {
            highScore = score;
            highEl.textContent = highScore;
            localStorage.setItem(HIGH_KEY, highScore);
            highEl.classList.remove("highlight");
            void highEl.offsetWidth;
            highEl.classList.add("highlight");
          }
          placeFood();
        } else {
          snake.shift();
        }
        lengthEl.textContent = snake.length;
        draw();
      };

      const togglePause = () => {
        paused = !paused;
        startBtn.textContent = paused ? "Resume" : "Restart";
        draw();
      };

      const draw = () => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // grid
        ctx.lineWidth = 1;
        for (let x = 0; x < cols; x++) {
          ctx.strokeStyle = x % 4 === 0 ? "rgba(122,252,255,0.12)" : "rgba(122,252,255,0.05)";
          ctx.beginPath();
          ctx.moveTo(x * cellSize, 0);
          ctx.lineTo(x * cellSize, rows * cellSize);
          ctx.stroke();
        }
        for (let y = 0; y < rows; y++) {
          ctx.strokeStyle = y % 4 === 0 ? "rgba(122,252,255,0.12)" : "rgba(122,252,255,0.05)";
          ctx.beginPath();
          ctx.moveTo(0, y * cellSize);
          ctx.lineTo(cols * cellSize, y * cellSize);
          ctx.stroke();
        }

        // food
        const fx = food.x * cellSize;
        const fy = food.y * cellSize;
        const gradient = ctx.createRadialGradient(
          fx + cellSize / 2,
          fy + cellSize / 2,
          cellSize * 0.1,
          fx + cellSize / 2,
          fy + cellSize / 2,
          cellSize * 0.7
        );
        gradient.addColorStop(0, "rgba(255,200,120,0.95)");
        gradient.addColorStop(1, "rgba(255,140,60,0.75)");
        ctx.fillStyle = gradient;
        ctx.shadowColor = "#ffb347";
        ctx.shadowBlur = 12;
        ctx.fillRect(fx, fy, cellSize, cellSize);
        ctx.shadowBlur = 0;

        // snake
        for (let i = 0; i < snake.length; i++) {
          const s = snake[i];
          const isHead = i === snake.length - 1;
          ctx.fillStyle = isHead ? "rgba(255,47,211,0.9)" : "rgba(74,240,255,0.9)";
          ctx.fillRect(s.x * cellSize, s.y * cellSize, cellSize, cellSize);
        }

        if (paused) {
          ctx.fillStyle = "rgba(0,0,0,0.45)";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "#7afcff";
          ctx.font = "22px " + getComputedStyle(document.body).fontFamily;
          ctx.textAlign = "center";
          ctx.fillText("Paused", canvas.width / 2, canvas.height / 2);
        }
      };

      const start = () => {
        clearInterval(loopId);
        speedMs = difficulties[currentMode]?.speed || difficulties.classic.speed;
        paused = false;
        reset();
        draw();
        speedEl.textContent = `${speedMs}ms`;
        loopId = setInterval(tick, speedMs);
        startBtn.textContent = "Restart";
      };

      const gameOver = () => {
        clearInterval(loopId);
        lastEl.textContent = score;
        startBtn.textContent = "Start";
        ctx.fillStyle = "rgba(0,0,0,0.45)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#7afcff";
        ctx.font = "24px " + getComputedStyle(document.body).fontFamily;
        ctx.textAlign = "center";
        ctx.fillText("Game Over", canvas.width / 2, canvas.height / 2);
      };

      // Input
      window.addEventListener("keydown", (e) => {
        const k = e.key.toLowerCase();
        if (k === " ") {
          e.preventDefault();
          if (loopId) togglePause();
          return;
        }
        if (k === "enter") {
          start();
          return;
        }
        if (k === "arrowup" || k === "w") setDirection(0, -1);
        else if (k === "arrowdown" || k === "s") setDirection(0, 1);
        else if (k === "arrowleft" || k === "a") setDirection(-1, 0);
        else if (k === "arrowright" || k === "d") setDirection(1, 0);
      });

      const touchHandler = (dir) => {
        switch (dir) {
          case "up": setDirection(0, -1); break;
          case "down": setDirection(0, 1); break;
          case "left": setDirection(-1, 0); break;
          case "right": setDirection(1, 0); break;
        }
      };

      dpadButtons.forEach(btn => {
        const dir = btn.dataset.dir;
        ["touchstart", "pointerdown"].forEach(ev => {
          btn.addEventListener(ev, (e) => {
            e.preventDefault();
            btn.classList.add("pressed");
            setTimeout(() => btn.classList.remove("pressed"), 120);
            touchHandler(dir);
          });
        });
      });

      modeSelect.addEventListener("change", () => {
        currentMode = modeSelect.value;
        localStorage.setItem(MODE_KEY, currentMode);
        speedMs = difficulties[currentMode]?.speed || difficulties.classic.speed;
        speedEl.textContent = `${speedMs}ms`;
        if (loopId) {
          clearInterval(loopId);
          loopId = setInterval(tick, speedMs);
        }
      });

      startBtn.addEventListener("click", () => {
        if (paused && loopId) {
          togglePause();
          return;
        }
        start();
      });
      window.addEventListener("resize", () => { resize(); draw(); });
      window.addEventListener("blur", () => {
        if (loopId && !paused) togglePause();
      });

      // Init
      resize();
      reset();
      speedEl.textContent = `${speedMs}ms`;
      startBtn.focus();
      draw();
    })();
  </script>
</body>
</html>
